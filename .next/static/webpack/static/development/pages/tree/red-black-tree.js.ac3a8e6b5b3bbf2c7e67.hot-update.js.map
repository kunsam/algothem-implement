{"version":3,"file":"static/webpack/static/development/pages/tree/red-black-tree.js.ac3a8e6b5b3bbf2c7e67.hot-update.js","sources":["webpack:///./src/view/tree/red-black-tree-viewobject.ts"],"sourcesContent":["import * as THREE from 'three';\nimport { message } from 'antd';\nimport 'antd/lib/message/style/index.css';\nimport FontManager from '../font/font-manager';\nimport AnimatorBase from './animator/animator-base';\nimport { RBNode, RBColor } from './../../tree/red-black-tree';\nimport RotatedAnimator from './animator/rotated-animator';\nimport { App } from './../../../pages/tree/red-black-tree';\nimport { getSphereNode, getConnectLineMesh } from './mesh';\nimport RecolorNodeAnimator from './animator/recolor-animator';\nimport VisitedNodeAnimator from './animator/visited-node-animator';\nimport { RedBlackTree, RBNodeDirtyInfo } from '../../tree/red-black-tree';\nimport ShowTextAnimator from './animator/show-text-animator';\n\n\nexport enum RBNodeDirtyType{\n  none = \"NONE\",\n  find = \"FIND\",\n  insert = \"INSERT\",\n  visited = \"VISITED\",\n  recolor = \"RECOLOR\",\n  leftRotated = \"LEFTROTATED\",\n  rightRotated = \"RIGHTROTATED\",\n}\n\n\nexport class RBNodeViewObject {\n  public node: RBNode;\n  public mesh: THREE.Mesh;\n\n  public dirty: boolean = false;\n  private _dirtyFrame: number = 0;\n  private _oldColor?: THREE.Color;\n  public static DirtyMaxFrame: number = 20;\n\n  constructor(node: RBNode, mesh: THREE.Mesh) {\n    this.mesh = mesh;\n    this.node = node;\n  }\n\n  public onDirtyAnimate(onEnd: Function) {\n    if (this.dirty && this._dirtyFrame < RBNodeViewObject.DirtyMaxFrame) {\n      if (!this._oldColor) {\n        this._oldColor = this.mesh.material.color;\n      }\n      this.mesh.material.color = new THREE.Color(0x00ff00)\n      this._dirtyFrame++;\n    } else if (this._dirtyFrame >= RBNodeViewObject.DirtyMaxFrame) {\n      this._dirtyFrame = 0;\n      this.dirty = false;\n      this.mesh.material.color = this._oldColor;\n      this._oldColor = undefined;\n      onEnd();\n    }\n  }\n}\n\n\n\n\nexport class RedBlackTreeViewObject extends THREE.Object3D {\n\n  public static originPosition = new THREE.Vector3(0, 400, 0);\n  public static horizontalOffset = 80;\n  public static verticalOffset = 160;\n\n  public tree: RedBlackTree;\n  private _animatorFlows: AnimatorBase[][] = [];\n  private _nodeViewObjectMap: Map<number, RBNodeViewObject> = new Map();\n\n  private _app: App;\n  private _currentActiveAnimatorsLength?: number;\n  private _currentEndAnimatorsLength: number = 0;\n\n  private _enterAnimating: boolean = false;\n\n\n  constructor(app: App, tree: RedBlackTree) {\n    super();\n    this._app = app;\n    this.tree = tree;\n    tree.levelOrderTraverse((node: RBNode) => {\n      this.addNode(node);\n    });\n  }\n\n  public static getChildPosition(rbNode: RBNode, parentPosition: THREE.Vector3) {\n    if (!parentPosition) {\n      return RedBlackTreeViewObject.originPosition;\n    } else {\n      const position = parentPosition.clone();\n      position.y -= RedBlackTreeViewObject.verticalOffset;\n      if (rbNode.isOnLeft()) {\n        position.x -= RedBlackTreeViewObject.horizontalOffset;\n        if (rbNode.sibling() && rbNode.hasChild()) {\n          position.x -= RedBlackTreeViewObject.horizontalOffset;\n        }\n      } else {\n        position.x += RedBlackTreeViewObject.horizontalOffset;\n        if (rbNode.sibling() && rbNode.hasChild()) {\n          position.x += RedBlackTreeViewObject.horizontalOffset;\n        }\n      }\n      return position;\n    }\n  }\n\n  public addNode(node: RBNode) {\n    const sphereNode = getSphereNode(node, FontManager.getFont('helv'));\n    if (sphereNode) {\n      const rbNode: RBNode = sphereNode.userData.node;\n      const parentPosition = rbNode && rbNode.parent && rbNode.parent.userData.position;\n      sphereNode.position.copy(RedBlackTreeViewObject.getChildPosition(rbNode, parentPosition))\n      node.userData.position = sphereNode.position;\n      const line = getConnectLineMesh(sphereNode);\n      if (line) {\n        line.userData.isConnectLine = true;\n        sphereNode.add(line);\n      }\n      this._nodeViewObjectMap.set(node.key, new RBNodeViewObject(node, sphereNode));\n      this.add(sphereNode);\n    }\n  }\n\n  public update() {\n\n    // 这里的写法有问题，应该先操作，然后标记对应的节点，按照顺序执行节点动画\n    // [ [ ...node], [], []]，前一组执行完才执行下一组\n    if (this._animatorFlows.length) {\n      this._enterAnimating = true;\n      this._animatorFlows.forEach((animators, index) => {\n        if (!animators.length) {\n          this._animatorFlows.shift()\n        } else {\n          if (index === 0) {\n            if (!this._currentActiveAnimatorsLength) {\n              this._currentActiveAnimatorsLength = animators.length;\n            }\n            animators.forEach(animator => {\n              const isAnimating = animator.animate();\n              if (!isAnimating) {\n                this._currentEndAnimatorsLength++;\n                if (this._currentEndAnimatorsLength === this._currentActiveAnimatorsLength) {\n                  this._animatorFlows.shift()\n                  this._currentEndAnimatorsLength = 0;\n                  this._currentActiveAnimatorsLength = undefined;\n                }\n              }\n            });\n          }\n        }\n      });\n    } else {\n      if (this._enterAnimating) {\n        message.info('Operation Done!', 0.1);\n        this._enterAnimating = false;\n        this._app.eventManager.emitOperationDone();\n      }\n    }\n  }\n\n  private _dityFlowsAnimationFlow(dirtyNodesFlows: RBNodeDirtyInfo[][]) {\n    const logs: any[] = [];\n    this._animatorFlows = [];\n    dirtyNodesFlows.forEach(nodeArray => {\n      logs.push(nodeArray.map(n => ({ dt: n.dirtyType, node: n.node })));\n      const animators: AnimatorBase[] = [];\n      nodeArray.forEach(info => {\n        switch (info.dirtyType) {\n          case RBNodeDirtyType.visited: {\n            if (!info.node) break;\n            const viewobject = this._nodeViewObjectMap.get(info.node.key);\n            if (viewobject) {\n              animators.push(new ShowTextAnimator({\n                node: info.node,\n                text: 'Visited',\n                mesh: viewobject.mesh,\n              }));\n              animators.push(new VisitedNodeAnimator(\n                info.node, viewobject.mesh\n              ));\n            }\n            break;\n          }\n          case RBNodeDirtyType.recolor: {\n            if (!info.node) break;\n            const viewobject = this._nodeViewObjectMap.get(info.node.key);\n            if (viewobject) {\n              animators.push(new ShowTextAnimator({\n                node: info.node,\n                text: 'ReColor',\n                mesh: viewobject.mesh,\n              }));\n              const isBlack = info.node.color === RBColor.black;\n              const color = isBlack ? 0x000000 : 0xff0000;\n              animators.push(new RecolorNodeAnimator(\n                info.node,\n                viewobject.mesh,\n                color\n              ));\n            }\n            break;\n          }\n          case RBNodeDirtyType.rightRotated:\n          case RBNodeDirtyType.leftRotated: {\n            if (!info.node) break;\n            animators.push(new RotatedAnimator(\n              info.node,\n              info.dirtyType,\n              this._nodeViewObjectMap,\n            ));\n            break;\n          }\n          case RBNodeDirtyType.find: {\n            // animators.push(new FindAnimator(\n            //   info.node,\n            //   this.font,\n            // ));\n          }\n        }\n      });\n      this._animatorFlows.push(animators);\n    });\n    console.log(logs, this._animatorFlows, 'this._animatorFlows')\n  }\n\n  public insert(key: number) {\n    if (!this.tree.root) {\n      this.tree.insert(key);\n      this.addNode(new RBNode(key));\n      return;\n    }\n    if (this.tree.search(key)) {\n      return;\n    }\n\n    const dirtyNodesFlows: RBNodeDirtyInfo[][] = this.tree.insert(key, (r) => {\n      this.addNode(r);\n    });\n    this._dityFlowsAnimationFlow(dirtyNodesFlows);\n  }\n\n  public delete(key: number) {\n    if (!this.tree.root) {\n      return;\n    }\n    const dirtyNodesFlows: RBNodeDirtyInfo[][] | undefined = this.tree.delete(key);\n    if (dirtyNodesFlows) {\n      this._dityFlowsAnimationFlow(dirtyNodesFlows);\n    }\n\n  }\n\n}"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAUA;AAAA;AAAA;AASA;AAAA;AACA;AADA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AAbA;AAAA;AAAA;AAeA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5BA;AACA;AADA;AAAA;AACA;AADA;AACA;AAiCA;AAAA;AAAA;AAAA;AACA;AAgBA;AAAA;AACA;AADA;AACA;AAAA;AACA;AAFA;AACA;AADA;AACA;AADA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAOA;AACA;AAzBA;AAAA;AAAA;AAgDA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AA9DA;AAAA;AAAA;AAgEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAnGA;AAAA;AAAA;AAqGA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAKA;AAGA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAKA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAKA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAlDA;AAoDA;AACA;AAAA;AACA;AACA;AACA;AApKA;AAAA;AAAA;AAsKA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AApLA;AAAA;AAAA;AAuLA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AA/LA;AAAA;AAAA;AA2BA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AA7CA;AACA;AADA;AAAA;AACA;AADA;AACA;AADA;AACA;AADA;;;;A","sourceRoot":""}